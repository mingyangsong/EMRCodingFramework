package edu.cmu.lti.uima.server;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.uima.UIMAFramework;
import org.apache.uima.aae.client.UimaAsBaseCallbackListener;
import org.apache.uima.aae.client.UimaAsynchronousEngine;
import org.apache.uima.adapter.jms.client.BaseUIMAAsynchronousEngine_impl;
import org.apache.uima.cas.CAS;
import org.apache.uima.collection.CollectionReader;
import org.apache.uima.collection.CollectionReaderDescription;
import org.apache.uima.collection.EntityProcessStatus;
import org.apache.uima.util.XMLInputSource;

import javax.servlet.http.HttpServletResponse;

/**
 * Example application that calls a Remote Asynchronous Analysis Engine on a
 * collection.
 * <p>
 * Arguments: brokerUrl endpoint [options] [-t Timeout] [-i]
 * <p>
 * This connects to a remote AE at specified brokerUrl and endpoint (which must
 * match what is in the service's deployment descriptor. The following optional
 * arguments are accepted:
 * <ul>
 * <li>-d Specifies a deployment descriptor. The specified service will be
 * deployed before processing begin, and the service will be undeployed after
 * processing completes. Multiple -d entries can be given.</li>
 * <li>-c Specifies a CollectionReader descriptor. The client will read CASes
 * from the CollectionReader and send them to the service for processing. If
 * this option is ommitted, one empty CAS will be sent to the service (useful
 * for services containing a CAS Multiplier acting as a collection reader).</li>
 * <li>-p Specifies CAS pool size, which determines the maximum number of
 * requests that can be outstanding.</li>
 * <li>-f Specifies the initial FS heap size in bytes of each CAS in the pool.</li>
 * <li>-o Specifies an Output Directory. All CASes received by the client's
 * CallbackListener will be serialized to XMI in the specified OutputDir. If
 * ommitted, no XMI files will be output.</li>
 * <li>-t Specifies a timeout period in seconds. If a CAS does not return within
 * this time period it is considered an error. By default there is no timeout,
 * so the client will wait forever.</li>
 * <li>-i Causes the client to ignore errors returned from the service. If not
 * specified, the client terminates on the first error.</li>
 * <li>-log Output details on each process request.</li>
 * <li>-uimaEeDebug true causes various debugging things to happen, including
 * *not* deleting the generated spring file generated by running dd-2-spring.
 * This parameter only affects deployments specified using the -d parameter that
 * follow it in the command line sequence.</li>
 * </ul>
 * 
 * @param <ActionResponse>
 * @param <ActionRequest>
 */
public class RunRemoteAsyncAE<ActionResponse, ActionRequest> {
	private String brokerUrl = "tcp://Yangs-MacBook-Pro.local:61616";

	private String endpoint = "EMRQueue";

	private File collectionReaderDescriptor = null;

	private int casPoolSize = 2;

	private int fsHeapSize = 2000000;

	private int timeout = 0;

	private int getmeta_timeout = 60;

	private int cpc_timeout = 0;

	private boolean ignoreErrors = false;

	private boolean logCas = false;

	private HttpServletResponse servletResponse = null;

	private String emrText = null;

	/**
	 * Start time of the processing - used to compute elapsed time.
	 */
	private static long mStartTime = System.nanoTime() / 1000000;

	private UimaAsynchronousEngine uimaEEEngine = null;

	Map<String, Object> appCtx;

	// For logging CAS activity
	private ConcurrentHashMap casMap = new ConcurrentHashMap();

	/**
	 * Constructor for the class. Parses command line arguments and sets the
	 * values of fields in this instance. If command line is invalid prints a
	 * message and calls System.exit().
	 * 
	 * @param args
	 *            command line arguments into the program - see class
	 *            description
	 * @throws Exception
	 */

	public RunRemoteAsyncAE(String emr, HttpServletResponse response) {
		appCtx = new HashMap<String, Object>();
		appCtx.put(UimaAsynchronousEngine.DD2SpringXsltFilePath,
				System.getenv("UIMA_HOME") + "/bin/dd2spring.xsl");
		appCtx.put(UimaAsynchronousEngine.SaxonClasspath,
				"file:" + System.getenv("UIMA_HOME") + "/saxon/saxon8.jar");
		// appCtx.put(UimaAsynchronousEngine.SerializationStrategy, "binary");

		emrText = emr;

		servletResponse = response;

	}

	public void run() throws Exception {

		if (uimaEEEngine == null) {
			// create Asynchronous Engine
			uimaEEEngine = new BaseUIMAAsynchronousEngine_impl();
		}

		// add Collection Reader if specified
		if (collectionReaderDescriptor != null) {
			CollectionReaderDescription collectionReaderDescription = UIMAFramework
					.getXMLParser().parseCollectionReaderDescription(
							new XMLInputSource(collectionReaderDescriptor));

			CollectionReader collectionReader = UIMAFramework
					.produceCollectionReader(collectionReaderDescription);

			uimaEEEngine.setCollectionReader(collectionReader);
		}
		uimaEEEngine
				.addStatusCallbackListener(new StatusCallbackListenerImpl());

		// set server URI and Endpoint
		// Add Broker URI
		appCtx.put(UimaAsynchronousEngine.ServerUri, brokerUrl);
		// Add Queue Name
		appCtx.put(UimaAsynchronousEngine.Endpoint, endpoint);
		// Add timeouts (UIMA EE expects it in milliseconds, but we use seconds
		// on the command line)
		appCtx.put(UimaAsynchronousEngine.Timeout, timeout * 1000);
		appCtx.put(UimaAsynchronousEngine.GetMetaTimeout,
				getmeta_timeout * 1000);
		appCtx.put(UimaAsynchronousEngine.CpcTimeout, cpc_timeout * 1000);

		// Add the Cas Pool Size and initial FS heap size
		appCtx.put(UimaAsynchronousEngine.CasPoolSize, casPoolSize);
		appCtx.put(UIMAFramework.CAS_INITIAL_HEAP_SIZE,
				Integer.valueOf(fsHeapSize / 4).toString());

		// initialize
		uimaEEEngine.initialize(appCtx);

		// run
		if (logCas) {
			System.out.println("\nService-IPaddr\tSent\tDuration");
		}
		if (collectionReaderDescriptor != null) {
			uimaEEEngine.process();
		} else {
			// send an empty CAS
			CAS cas = uimaEEEngine.getCAS();
			cas.setDocumentText(emrText);

			uimaEEEngine.sendCAS(cas);
			System.out.println("Client request CAS has been sent!");
			uimaEEEngine.collectionProcessingComplete();
		}

		uimaEEEngine.stop();
	}

	/**
	 * Callback Listener. Receives event notifications from CPE.
	 * 
	 * 
	 */
	class StatusCallbackListenerImpl extends UimaAsBaseCallbackListener {
		int entityCount = 0;

		long size = 0;

		/**
		 * Called when the initialization is completed.
		 * 
		 * @see org.apache.uima.collection.processing.StatusCallbackListener#initializationComplete()
		 */
		public void initializationComplete(EntityProcessStatus aStatus) {
			if (aStatus != null && aStatus.isException()) {
				System.err.println("Error on getMeta call to remote service:");
				List exceptions = aStatus.getExceptions();
				for (int i = 0; i < exceptions.size(); i++) {
					((Throwable) exceptions.get(i)).printStackTrace();
				}
				System.err.println("Terminating Client...");
				stop();

			}
			System.out.println("UIMA AS Service Initialization Complete");
		}

		private void stop() {
			try {
				uimaEEEngine.stop();
			} catch (Exception e) {

			}
			System.exit(1);

		}

		/**
		 * Called when the collection processing is completed.
		 * 
		 * @see org.apache.uima.collection.processing.StatusCallbackListener#collectionProcessComplete()
		 */
		public void collectionProcessComplete(EntityProcessStatus aStatus) {

			System.out
					.println("---------------------------Collection Process is completed!---------------------------");

			if (aStatus != null && aStatus.isException()) {
				System.err
						.println("Error on collection process complete call to remote service:");
				List exceptions = aStatus.getExceptions();
				for (int i = 0; i < exceptions.size(); i++) {
					((Throwable) exceptions.get(i)).printStackTrace();
				}
				System.err.println("Terminating Client...");
				stop();
			}
			System.out.print("Completed " + entityCount + " documents");
			if (size > 0) {
				System.out.print("; " + size + " characters");
			}
			System.out.println();
			long elapsedTime = System.nanoTime() / 1000000 - mStartTime;
			System.out.println("Time Elapsed : " + elapsedTime + " ms ");

			String perfReport = uimaEEEngine.getPerformanceReport();
			if (perfReport != null) {
				System.out
						.println("\n\n ------------------ PERFORMANCE REPORT ------------------\n");
				System.out.println(uimaEEEngine.getPerformanceReport());
			}
			// stop the JVM.
			// stop();
		}

		/**
		 * Called when the processing of a Document is completed. <br>
		 * The process status can be looked at and corresponding actions taken.
		 * 
		 * @param aCas
		 *            CAS corresponding to the completed processing
		 * @param aStatus
		 *            EntityProcessStatus that holds the status of all the
		 *            events for aEntity
		 */
		public void entityProcessComplete(CAS aCas, EntityProcessStatus aStatus) {

			try {
				// pass the response CAS into JD.java
				String xmlResponse = this.formXML(aCas);

				servletResponse.getWriter().write(xmlResponse);

			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			System.out
					.println("---------------------------Entity Process is completed!---------------------------");
			System.out.println(aStatus.toString());

		}

		private String formXML(CAS cas) {

			String xml = "<emrCases>" + "<emr>" + "<content>"
					+ cas.getDocumentText() + "</content>" + "<icd>"
					+ "1234567890" + "</icd>" + "</emr>" + "</emrCases>";

			return xml;

		}
	}
}
